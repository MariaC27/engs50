https://thayer.github.io/engs50/Notes/iterators/
2
32569
<!DOCTYPEhtml><html><head><metacharset="utf-8"><metahttp-equiv="X-UA-Compatible"content="IE=edge"><metaname="viewport"content="width=device-width,initial-scale=1"><title>Iterators</title><metaname="description"content="InEngs50youwilllearnhowtodesign&buildlarge,reliable,maintainable,andunderstandablesoftwaresystems.IntheprocessyouwilllearntoprograminCwithUnixdevelopmenttools."><linkrel="shortcuticon"href="/engs50/50.png"/><linkrel="stylesheet"href="/engs50/css/main.css"><linkrel="canonical"href="/engs50/Notes/iterators/"></head><body><headerclass="site-header"><aclass="site-title"href="/engs50/"><imgwidth=48align=centersrc="/engs50/50.png"alt="icon">Engs50(CS50)</a><navclass="site-nav">[<ahref="/engs50/Labs/">Labs</a>][<ahref="/engs50/Notes/">Notes</a>][<ahref="/engs50/Reading/">Reading</a>][<ahref="/engs50/Resources/">Resources</a>][<ahref="/engs50/Examples/">Examples</a>]</nav></header><divclass="page-content"><divclass="wrapper"><articleclass="post"><headerclass="post-header"><h1class="post-title">Iterators</h1></header><divclass="post-content"><p>Inthislecture,wewilllearnabout<em>Iterators</em>andtheiruses:</p><ul><li>whatisanIterator</li><li>howisitcodedinthecontextofourdatastructures</li><li>howitleveragesfunctionpointersinC</li><li>passingargumentstointerators</li><li>severalusesofiterators</li></ul><h2id="why-iterators">Whyiterators?</h2><p><em>Iterators</em>areapowerfulconcept,especiallywhenwritinganabstractdatastructurethatrepresentsacollection.Wehaveseveralsuchdatastructures-tree,bag,set,hashtable,andcounters.Ifthecollectionimplementsan<em>iterator</em>,wecanapplysomefunctiontoeveryiteminthatcollection…e.g.,forprinting,counting,modifying,andevencombiningmultiplecollections.</p><p>InLab5youwillfinditeratorshelpfulinwritingthecontentsoftheIndextotheindexfile.</p><p>InLab6youwillfinditeratorshelpfulincombiningthesetofmatchesforonewordwiththesetofmatchesforanotherword.</p><h2id="coding-an-iterator">Codinganiterator</h2><p>Lab3askedyoutoincludean<codeclass="language-plaintexthighlighter-rouge">_iterate()</code>methodineachof<codeclass="language-plaintexthighlighter-rouge">set</code>,<codeclass="language-plaintexthighlighter-rouge">hashtable</code>,and<codeclass="language-plaintexthighlighter-rouge">counters</code>.Yousawthe<codeclass="language-plaintexthighlighter-rouge">bag_iterate()</code>methodasanexample:</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="cm">/*Iterateoverthewholebag;callthegivenfunctiononeachitem,*passingboththeitemandanargument.IgnoreifNULLbagorNULLitemfunc.*/</span><spanclass="kt">void</span><spanclass="nf">bag_iterate</span><spanclass="p">(</span><spanclass="n">bag_t</span><spanclass="o">*</span><spanclass="n">bag</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="p">(</span><spanclass="o">*</span><spanclass="n">itemfunc</span><spanclass="p">)(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">bag</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="o">&amp;&amp;</span><spanclass="n">itemfunc</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="c1">//callitemfuncwitharg,oneachitem</span><spanclass="k">for</span><spanclass="p">(</span><spanclass="n">bagnode_t</span><spanclass="o">*</span><spanclass="n">node</span><spanclass="o">=</span><spanclass="n">bag</span><spanclass="o">-&gt;</span><spanclass="n">head</span><spanclass="p">;</span><spanclass="n">node</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="p">;</span><spanclass="n">node</span><spanclass="o">=</span><spanclass="n">node</span><spanclass="o">-&gt;</span><spanclass="n">next</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="p">(</span><spanclass="o">*</span><spanclass="n">itemfunc</span><spanclass="p">)(</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="n">node</span><spanclass="o">-&gt;</span><spanclass="n">item</span><spanclass="p">);</span><spanclass="p">}</span><spanclass="p">}</span><spanclass="p">}</span></code></pre></div></div><p>Noticethatthecodebeginswithdefensiveprogramming-incasethecalleraccidentallycallsuswithNULLparameters.</p><p>Otherwise,thefunctionisasimple<codeclass="language-plaintexthighlighter-rouge">for</code>loop,steppingthrougheachiteminthebag.Thisiteratormakesnopromiseaboutthe<em>order</em>inwhichitprocessesitems;afterall,a‘bag’isanunordered,unlabeledcollectionof‘things’.</p><h2id="function-pointers">Functionpointers</h2><p>Recallourdiscussionof<em>functionpointers</em>fromearlierintheterm.Thesecondparameterto<codeclass="language-plaintexthighlighter-rouge">bag_iterate</code>declares<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>asa<em>pointertoafunction</em>thatitselftakestwoparameters:an<codeclass="language-plaintexthighlighter-rouge">arg</code>anda<codeclass="language-plaintexthighlighter-rouge">data</code>.Botharevoidpointers,thatis,pointersto<em>someunspecifiedtype</em>.Becausetheiteratorreceivesafunctionpointerfromitscaller,andthearg/dataparametersarearbitrarypointers,thisiteratorcanworkonitemsofanytype,andcomputeanysortoffunctiononthoseitems,makingittrulygeneral-purpose.</p><p>Lookinsidethe<codeclass="language-plaintexthighlighter-rouge">for</code>loop,wherewecall<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>.Here,wedereferencethe<em>functionpointer</em>togeta<em>function</em>,thencallitwithtwoparameters:the<codeclass="language-plaintexthighlighter-rouge">arg</code>providedtous,andthedataforthisitem.(Syntactically,wehavetowrapthedereferenceinparentheses,butotherwise,it’sjustlikeanyotherfunctioncall.)</p><h2id="arguments">Arguments</h2><p>Sometimes,thoughnotalways,thecallerwillneedawayofcommunicatingotherinformationtothe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>-notjusttheinformationabouttheitemouriteratorcanprovide.Thus,theiteratortakes<codeclass="language-plaintexthighlighter-rouge">arg</code>,apointertoarbitrarysomething,andpassesitrightonthroughtothe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>.Thismechanismisgeneral-purpose:</p><ul><li>pass<codeclass="language-plaintexthighlighter-rouge">arg=NULL</code>ifthecallerhasnoneedtosendadditionalargumentstoits<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>;</li><li>passapointertoasimplevariableifthecallerjustneedstogetinformationintothe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>;</li><li>indeed,inthatcase,thevariableispassed<em>byreference</em>andthusthe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>canupdatethevariableifneeded;</li><li>furthermore,ifthecallerneedstosendmultiplethingstothe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>,itcanpassapointertoa<codeclass="language-plaintexthighlighter-rouge">struct</code>holdingthosethings.</li></ul><p>We’llseeexamplesbywritingsomecodethatusesour<codeclass="language-plaintexthighlighter-rouge">bag_iterate()</code>andmy<codeclass="language-plaintexthighlighter-rouge">set_iterate()</code>functions.</p><h2id="examples-with-bag_iterate">Exampleswithbag_iterate()</h2><p>Threeexamplesfrom<ahref="/engs50/Labs/Lab3/starter/bag/bagtest.c">bagtest.c</a>.</p><p><strong><em>Printing.</em></strong>First,let’ssupposewedon’thave(ordon’tlike)theexisting<codeclass="language-plaintexthighlighter-rouge">bag_print()</code>method,whichtendstoprintsometext/formattingaroundeachitem.Wecanuseournewiterator:</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">Simpleprint:</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="n">bag_iterate</span><spanclass="p">(</span><spanclass="n">bag</span><spanclass="p">,</span><spanclass="n">stdout</span><spanclass="p">,</span><spanclass="n">simpleprint</span><spanclass="p">);</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="p">...</span><spanclass="cm">/*printthegivenitemtothegivenfile;*justprintthestocksymbol*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">simpleprint</span><spanclass="p">(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="kt">FILE</span><spanclass="o">*</span><spanclass="n">fp</span><spanclass="o">=</span><spanclass="n">arg</span><spanclass="p">;</span><spanclass="k">struct</span><spanclass="n">stock</span><spanclass="o">*</span><spanclass="n">stp</span><spanclass="o">=</span><spanclass="n">item</span><spanclass="p">;</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">fp</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="o">&amp;&amp;</span><spanclass="n">stp</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="p">)</span><spanclass="n">fprintf</span><spanclass="p">(</span><spanclass="n">fp</span><spanclass="p">,</span><spanclass="s">"%s"</span><spanclass="p">,</span><spanclass="n">stp</span><spanclass="o">-&gt;</span><spanclass="n">symbol</span><spanclass="p">);</span><spanclass="p">}</span></code></pre></div></div><p>Here,wepassthefilepointerthroughthe<codeclass="language-plaintexthighlighter-rouge">arg</code>parameter.Noticehow<codeclass="language-plaintexthighlighter-rouge">simpleprint</code>immediatelycopiesits<codeclass="language-plaintexthighlighter-rouge">arg</code>,<codeclass="language-plaintexthighlighter-rouge">data</code>parametersintolocalvariablesoftherighttype.Thatgivesthemmorereadablenames,allowsthecompilertocheckthecodethatfollows,andallowsustousestructurepointers(like<codeclass="language-plaintexthighlighter-rouge">stp</code>)toreachmembersofthosestructures.</p><p><strong><em>Counting.</em></strong>Evensimpler,wecouldjustcounttheitems.Butwheredoweputthecounter?Definealocalvariableandpassitsaddressasthe<codeclass="language-plaintexthighlighter-rouge">arg</code>:</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">Count:"</span><spanclass="p">);</span><spanclass="kt">int</span><spanclass="n">nitems</span><spanclass="o">=</span><spanclass="mi">0</span><spanclass="p">;</span><spanclass="n">bag_iterate</span><spanclass="p">(</span><spanclass="n">bag</span><spanclass="p">,</span><spanclass="o">&amp;</span><spanclass="n">nitems</span><spanclass="p">,</span><spanclass="n">itemcount</span><spanclass="p">);</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"%d</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">nitems</span><spanclass="p">);</span><spanclass="p">...</span><spanclass="cm">/*countthenon-nullitemsinthebag.*noteherewedon'tcarewhatkindofitemisinbag.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">itemcount</span><spanclass="p">(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="kt">int</span><spanclass="o">*</span><spanclass="n">nitems</span><spanclass="o">=</span><spanclass="n">arg</span><spanclass="p">;</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">nitems</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="o">&amp;&amp;</span><spanclass="n">item</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="p">)</span><spanclass="p">(</span><spanclass="o">*</span><spanclass="n">nitems</span><spanclass="p">)</span><spanclass="o">++</span><spanclass="p">;</span><spanclass="p">}</span></code></pre></div></div><p><strong><em>Multiplearguments.</em></strong>Whatifwewanttwocounters?Inthisversionof<codeclass="language-plaintexthighlighter-rouge">bagtest</code>Ireadinstockquotes:symbol,previousclosingprice,currentprice,andtradingvolume.Let’sjustcountthenumberofgainersandnumberoflosers.</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="c1">//alittlestructuretocarrytwocounters.</span><spanclass="k">struct</span><spanclass="n">gainloss</span><spanclass="p">{</span><spanclass="kt">int</span><spanclass="n">ngainers</span><spanclass="p">;</span><spanclass="kt">int</span><spanclass="n">nlosers</span><spanclass="p">;</span><spanclass="p">};</span><spanclass="p">...</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">Changes:"</span><spanclass="p">);</span><spanclass="k">struct</span><spanclass="n">gainloss</span><spanclass="n">changes</span><spanclass="o">=</span><spanclass="p">{</span><spanclass="mi">0</span><spanclass="p">,</span><spanclass="mi">0</span><spanclass="p">};</span><spanclass="n">bag_iterate</span><spanclass="p">(</span><spanclass="n">bag</span><spanclass="p">,</span><spanclass="o">&amp;</span><spanclass="n">changes</span><spanclass="p">,</span><spanclass="n">stockgainloss</span><spanclass="p">);</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"gainers:%d;losers:%d</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">changes</span><spanclass="p">.</span><spanclass="n">ngainers</span><spanclass="p">,</span><spanclass="n">changes</span><spanclass="p">.</span><spanclass="n">nlosers</span><spanclass="p">);</span><spanclass="p">...</span><spanclass="cm">/*countthenumberofgainersandlosers.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">stockgainloss</span><spanclass="p">(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="k">struct</span><spanclass="n">gainloss</span><spanclass="o">*</span><spanclass="n">gl</span><spanclass="o">=</span><spanclass="n">arg</span><spanclass="p">;</span><spanclass="k">struct</span><spanclass="n">stock</span><spanclass="o">*</span><spanclass="n">stp</span><spanclass="o">=</span><spanclass="n">item</span><spanclass="p">;</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">gl</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="o">&amp;&amp;</span><spanclass="n">stp</span><spanclass="o">!=</span><spanclass="nb">NULL</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">stp</span><spanclass="o">-&gt;</span><spanclass="n">price</span><spanclass="o">&gt;</span><spanclass="n">stp</span><spanclass="o">-&gt;</span><spanclass="n">close</span><spanclass="p">)</span><spanclass="n">gl</span><spanclass="o">-&gt;</span><spanclass="n">ngainers</span><spanclass="o">++</span><spanclass="p">;</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">stp</span><spanclass="o">-&gt;</span><spanclass="n">price</span><spanclass="o">&lt;</span><spanclass="n">stp</span><spanclass="o">-&gt;</span><spanclass="n">close</span><spanclass="p">)</span><spanclass="n">gl</span><spanclass="o">-&gt;</span><spanclass="n">nlosers</span><spanclass="o">++</span><spanclass="p">;</span><spanclass="p">}</span><spanclass="p">}</span></code></pre></div></div><p>Oncethestuctureisdefined,ouruseofiteratorisverymuchlikethepreviousexample.Wedefineandinitializealocalvariable,passapointertothatvariableasour<codeclass="language-plaintexthighlighter-rouge">arg</code>,andthenthe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>copiesthatpointerintoapointeroftherelevanttypesoitcanaccess(andupdate)thecontents.<em>Noticethatitisnotnecessaryto<codeclass="language-plaintexthighlighter-rouge">malloc</code>spaceinordertopassapointertotheiterator</em>-inthisexample,<codeclass="language-plaintexthighlighter-rouge">&amp;changes</code>isapointertoalocalvariable.</p><h2id="examples-with-set_iterate">Exampleswithset_iterate()</h2><p>The‘bag’moduleisnicebecauseitisverysimple,butwecandomoreinterestingthingswhentheitemshavea<codeclass="language-plaintexthighlighter-rouge">key</code>aswell.Let’suse<codeclass="language-plaintexthighlighter-rouge">set_iterate</code>fortwoexamples.</p><p>Seemyterminal<ahref="/engs50/Notes/iterators/script.txt">script</a>forthecodeandatestrun.</p><p><strong><em>Mergingtwosets.</em></strong>We’llstartwithasimplecase.Herethesetsrepresentschools,wherethe<codeclass="language-plaintexthighlighter-rouge">key</code>isthenameoftheschool.See<ahref="/engs50/Examples/set_iterate1.c">set_iterate1</a>.(Notealso<ahref="/engs50/Examples/set_iterate.makefile">set_iterate.makefile</a>.)</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="o">*</span><spanclass="n">setB</span><spanclass="p">,</span><spanclass="o">*</span><spanclass="n">result</span><spanclass="p">;</span><spanclass="c1">//threesets</span><spanclass="p">...</span><spanclass="n">initialize</span><spanclass="n">each</span><spanclass="n">set</span><spanclass="n">with</span><spanclass="n">set_new</span><spanclass="p">...</span><spanclass="n">fill</span><spanclass="n">setA</span><spanclass="n">and</span><spanclass="n">setB</span><spanclass="n">with</span><spanclass="n">set_insert</span><spanclass="nf">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">MergeofsetAintoresult:</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="n">set_merge</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">setA</span><spanclass="p">);</span><spanclass="n">set_print</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">stdout</span><spanclass="p">,</span><spanclass="n">itemprint</span><spanclass="p">);</span><spanclass="n">putchar</span><spanclass="p">(</span><spanclass="sc">'\n'</span><spanclass="p">);</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">MergeofsetBintoresult:</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="n">set_merge</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">setB</span><spanclass="p">);</span><spanclass="n">set_print</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">stdout</span><spanclass="p">,</span><spanclass="n">itemprint</span><spanclass="p">);</span><spanclass="n">putchar</span><spanclass="p">(</span><spanclass="sc">'\n'</span><spanclass="p">);</span><spanclass="p">...</span><spanclass="cm">/*Mergethesecondsetintothefirstset;*thesecondsetisunchanged.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">set_merge</span><spanclass="p">(</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setB</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="n">set_iterate</span><spanclass="p">(</span><spanclass="n">setB</span><spanclass="p">,</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">set_merge_helper</span><spanclass="p">);</span><spanclass="p">}</span><spanclass="cm">/*Consideroneitemforinsertionintotheotherset.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">set_merge_helper</span><spanclass="p">(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="k">const</span><spanclass="kt">char</span><spanclass="o">*</span><spanclass="n">key</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setA</span><spanclass="o">=</span><spanclass="n">arg</span><spanclass="p">;</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">set_insert</span><spanclass="p">(</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">,</span><spanclass="n">item</span><spanclass="p">))</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\t</span><spanclass="s">%sadded</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">);</span><spanclass="k">else</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\t</span><spanclass="s">%sexists</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">);</span><spanclass="p">}</span></code></pre></div></div><p>Noticehowtheaboveapproachiteratesoveroneset(setB)and,foreachiteminthatset,triestoinsertorupdateitsvalueinthefirstset(setA).Attheend,setBisunchangedbutsetAshouldhaveallitemsfrombothsets.</p><p><strong><em>Mergingtwosetsandtheirdata.</em></strong>Nowamoreinterestingcase,inwhichthesetitemseachholddatawewanttocombine.Inthissimpletest,thatdatumisjustaninteger-actually,apointertoaninteger.See<ahref="/engs50/Examples/set_iterate2.c">set_iterate2</a>.(Notealso<ahref="/engs50/Examples/set_iterate.makefile">set_iterate.makefile</a>.)</p><p>Inthisexample,setAandsetBeachcontainasetofschoolnames,andanumberforeachschool(say,perhaps,thenumberofpeopleyouknowateachschool).Whenmergingtwosetsyouwantthedataintheresultingsettorepresentthesumofthevaluesineachset.</p><divclass="language-chighlighter-rouge"><divclass="highlight"><preclass="highlight"><code><spanclass="n">set_insert</span><spanclass="p">(</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="s">"Dartmouth"</span><spanclass="p">,</span><spanclass="n">intsave</span><spanclass="p">(</span><spanclass="mi">20</span><spanclass="p">));</span><spanclass="p">...</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">MergeofsetAintoresult:</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="n">set_merge</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">setA</span><spanclass="p">);</span><spanclass="n">set_print</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">stdout</span><spanclass="p">,</span><spanclass="n">itemprint</span><spanclass="p">);</span><spanclass="n">putchar</span><spanclass="p">(</span><spanclass="sc">'\n'</span><spanclass="p">);</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\n</span><spanclass="s">MergeofsetBintoresult:</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">);</span><spanclass="n">set_merge</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">setB</span><spanclass="p">);</span><spanclass="n">set_print</span><spanclass="p">(</span><spanclass="n">result</span><spanclass="p">,</span><spanclass="n">stdout</span><spanclass="p">,</span><spanclass="n">itemprint</span><spanclass="p">);</span><spanclass="n">putchar</span><spanclass="p">(</span><spanclass="sc">'\n'</span><spanclass="p">);</span><spanclass="p">...</span><spanclass="cm">/*Mergethesecondsetintothefirstset;*thesecondsetisunchanged.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">set_merge</span><spanclass="p">(</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setB</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="n">set_iterate</span><spanclass="p">(</span><spanclass="n">setB</span><spanclass="p">,</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">set_merge_helper</span><spanclass="p">);</span><spanclass="p">}</span><spanclass="cm">/*Consideroneitemforinsertionintotheotherset.*Iftheothersetdoesnotcontaintheitem,insertit;*otherwise,updatetheotherset'sitemwithsumofitemvalues.*/</span><spanclass="k">static</span><spanclass="kt">void</span><spanclass="nf">set_merge_helper</span><spanclass="p">(</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">arg</span><spanclass="p">,</span><spanclass="k">const</span><spanclass="kt">char</span><spanclass="o">*</span><spanclass="n">key</span><spanclass="p">,</span><spanclass="kt">void</span><spanclass="o">*</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="n">set_t</span><spanclass="o">*</span><spanclass="n">setA</span><spanclass="o">=</span><spanclass="n">arg</span><spanclass="p">;</span><spanclass="kt">int</span><spanclass="o">*</span><spanclass="n">itemB</span><spanclass="o">=</span><spanclass="n">item</span><spanclass="p">;</span><spanclass="c1">//findthesamekeyinsetA</span><spanclass="kt">int</span><spanclass="o">*</span><spanclass="n">itemA</span><spanclass="o">=</span><spanclass="n">set_find</span><spanclass="p">(</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">);</span><spanclass="k">if</span><spanclass="p">(</span><spanclass="n">itemA</span><spanclass="o">==</span><spanclass="nb">NULL</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="c1">//notfound:insertit</span><spanclass="n">set_insert</span><spanclass="p">(</span><spanclass="n">setA</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">,</span><spanclass="n">intsave</span><spanclass="p">(</span><spanclass="o">*</span><spanclass="n">itemB</span><spanclass="p">));</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\t</span><spanclass="s">%sadded</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">);</span><spanclass="p">}</span><spanclass="k">else</span><spanclass="p">{</span><spanclass="c1">//addtotheexistingvalue</span><spanclass="o">*</span><spanclass="n">itemA</span><spanclass="o">+=</span><spanclass="o">*</span><spanclass="n">itemB</span><spanclass="p">;</span><spanclass="n">printf</span><spanclass="p">(</span><spanclass="s">"</span><spanclass="se">\t</span><spanclass="s">%sexists</span><spanclass="se">\n</span><spanclass="s">"</span><spanclass="p">,</span><spanclass="n">key</span><spanclass="p">);</span><spanclass="p">}</span><spanclass="p">}</span><spanclass="k">static</span><spanclass="kt">int</span><spanclass="o">*</span><spanclass="nf">intsave</span><spanclass="p">(</span><spanclass="kt">int</span><spanclass="n">item</span><spanclass="p">)</span><spanclass="p">{</span><spanclass="kt">int</span><spanclass="o">*</span><spanclass="n">saved</span><spanclass="o">=</span><spanclass="n">assertp</span><spanclass="p">(</span><spanclass="n">malloc</span><spanclass="p">(</span><spanclass="k">sizeof</span><spanclass="p">(</span><spanclass="kt">int</span><spanclass="p">)),</span><spanclass="s">"intsave"</span><spanclass="p">);</span><spanclass="o">*</span><spanclass="n">saved</span><spanclass="o">=</span><spanclass="n">item</span><spanclass="p">;</span><spanclass="k">return</span><spanclass="n">saved</span><spanclass="p">;</span><spanclass="p">}</span></code></pre></div></div><p>Theoverallstructureofthecodeisidenticaltothepriorexample;thedifferencehereisthatweneedtolookupthekeyinthedestinationsetfirstandthenperhapsupdateitsdata-becausewegeta<em>pointer</em>tothedata,wecaneasilyreachinandupdateitsvalue!</p><h2id="summary">Summary</h2><p>Iteratorsaresuperpowerful.Functionpointersaregreat!</p><h2id="activity">Activity</h2><p>You’venowseenhowtoconstructthe<em>union</em>oftwosets.Intoday’s<ahref="activity.html">activity</a>yourgroupdiscusseshowyouwouldconstructthe<em>intersection</em>oftwosets-it’sveryanalogous,butabittrickier.(Ifoundthatthe<codeclass="language-plaintexthighlighter-rouge">itemfunc</code>neededapointertoeachset,notjusttheoneset,asintheexampleabove.)</p></div></article></div></div><footerclass="site-footer"><divclass="wrapper"><h2class="footer-heading">Engs50(CS50)--DartmouthCollege</h2><p><fontsize=-1>ThisversionofthecourseisbaseduponthosedesignedbyProfessorsPalmer,Kotz,Zhou,Campbell,andBalkcom.Iamdeeplyindebtedtotheseoutstandingeducators.--<ahref="https://engineering.dartmouth.edu/people/faculty/stephen-taylor/">StephenTaylor</a></font></p><p><small>Thispagewaslastupdatedon<strong>2023-01-05</strong>at<strong>11:31</strong>.</small></p></div></footer></body></html>
